From 10011fa69d03951861f640b75d00465a860d5851 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Tue, 5 Mar 2019 15:26:27 -0600
Subject: [PATCH 1/2] xenomai pre-patchset

---
 drivers/pci/dwc/pcie-designware-host.c | 405 +++++++++++--------------
 drivers/thermal/hisi_thermal.c         | 318 ++++++++++---------
 2 files changed, 331 insertions(+), 392 deletions(-)

diff --git a/drivers/pci/dwc/pcie-designware-host.c b/drivers/pci/dwc/pcie-designware-host.c
index a89ffda64303..bc3e2d8d0cce 100644
--- a/drivers/pci/dwc/pcie-designware-host.c
+++ b/drivers/pci/dwc/pcie-designware-host.c
@@ -11,7 +11,6 @@
  * published by the Free Software Foundation.
  */
 
-#include <linux/irqchip/chained_irq.h>
 #include <linux/irqdomain.h>
 #include <linux/of_address.h>
 #include <linux/of_pci.h>
@@ -46,46 +45,22 @@ static int dw_pcie_wr_own_conf(struct pcie_port *pp, int where, int size,
 	return dw_pcie_write(pci->dbi_base + where, size, val);
 }
 
-static void dw_msi_ack_irq(struct irq_data *d)
-{
-	irq_chip_ack_parent(d);
-}
-
-static void dw_msi_mask_irq(struct irq_data *d)
-{
-	pci_msi_mask_irq(d);
-	irq_chip_mask_parent(d);
-}
-
-static void dw_msi_unmask_irq(struct irq_data *d)
-{
-	pci_msi_unmask_irq(d);
-	irq_chip_unmask_parent(d);
-}
-
-static struct irq_chip dw_pcie_msi_irq_chip = {
+static struct irq_chip dw_msi_irq_chip = {
 	.name = "PCI-MSI",
-	.irq_ack = dw_msi_ack_irq,
-	.irq_mask = dw_msi_mask_irq,
-	.irq_unmask = dw_msi_unmask_irq,
-};
-
-static struct msi_domain_info dw_pcie_msi_domain_info = {
-	.flags	= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
-		   MSI_FLAG_PCI_MSIX | MSI_FLAG_MULTI_PCI_MSI),
-	.chip	= &dw_pcie_msi_irq_chip,
+	.irq_enable = pci_msi_unmask_irq,
+	.irq_disable = pci_msi_mask_irq,
+	.irq_mask = pci_msi_mask_irq,
+	.irq_unmask = pci_msi_unmask_irq,
 };
 
 /* MSI int handler */
 irqreturn_t dw_handle_msi_irq(struct pcie_port *pp)
 {
+	u32 val;
 	int i, pos, irq;
-	u32 val, num_ctrls;
 	irqreturn_t ret = IRQ_NONE;
 
-	num_ctrls = pp->num_vectors / MAX_MSI_IRQS_PER_CTRL;
-
-	for (i = 0; i < num_ctrls; i++) {
+	for (i = 0; i < MAX_MSI_CTRLS; i++) {
 		dw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_STATUS + i * 12, 4,
 				    &val);
 		if (!val)
@@ -96,9 +71,9 @@ irqreturn_t dw_handle_msi_irq(struct pcie_port *pp)
 		while ((pos = find_next_bit((unsigned long *) &val, 32,
 					    pos)) != 32) {
 			irq = irq_find_mapping(pp->irq_domain, i * 32 + pos);
+			generic_handle_irq(irq);
 			dw_pcie_wr_own_conf(pp, PCIE_MSI_INTR0_STATUS + i * 12,
 					    4, 1 << pos);
-			generic_handle_irq(irq);
 			pos++;
 		}
 	}
@@ -106,230 +81,209 @@ irqreturn_t dw_handle_msi_irq(struct pcie_port *pp)
 	return ret;
 }
 
-/* Chained MSI interrupt service routine */
-static void dw_chained_msi_isr(struct irq_desc *desc)
+void dw_pcie_msi_init(struct pcie_port *pp)
 {
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	struct pcie_port *pp;
-
-	chained_irq_enter(chip, desc);
+	u64 msi_target;
 
-	pp = irq_desc_get_handler_data(desc);
-	dw_handle_msi_irq(pp);
+	pp->msi_data = __get_free_pages(GFP_KERNEL, 0);
+	msi_target = virt_to_phys((void *)pp->msi_data);
 
-	chained_irq_exit(chip, desc);
+	/* program the msi_data */
+	dw_pcie_wr_own_conf(pp, PCIE_MSI_ADDR_LO, 4,
+			    (u32)(msi_target & 0xffffffff));
+	dw_pcie_wr_own_conf(pp, PCIE_MSI_ADDR_HI, 4,
+			    (u32)(msi_target >> 32 & 0xffffffff));
 }
 
-static void dw_pci_setup_msi_msg(struct irq_data *data, struct msi_msg *msg)
+static void dw_pcie_msi_clear_irq(struct pcie_port *pp, int irq)
 {
-	struct pcie_port *pp = irq_data_get_irq_chip_data(data);
-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
-	u64 msi_target;
-
-	if (pp->ops->get_msi_addr)
-		msi_target = pp->ops->get_msi_addr(pp);
-	else
-		msi_target = (u64)pp->msi_data;
-
-	msg->address_lo = lower_32_bits(msi_target);
-	msg->address_hi = upper_32_bits(msi_target);
+	unsigned int res, bit, val;
 
-	if (pp->ops->get_msi_data)
-		msg->data = pp->ops->get_msi_data(pp, data->hwirq);
-	else
-		msg->data = data->hwirq;
-
-	dev_dbg(pci->dev, "msi#%d address_hi %#x address_lo %#x\n",
-		(int)data->hwirq, msg->address_hi, msg->address_lo);
+	res = (irq / 32) * 12;
+	bit = irq % 32;
+	dw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4, &val);
+	val &= ~(1 << bit);
+	dw_pcie_wr_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4, val);
 }
 
-static int dw_pci_msi_set_affinity(struct irq_data *irq_data,
-				   const struct cpumask *mask, bool force)
+static void clear_irq_range(struct pcie_port *pp, unsigned int irq_base,
+			    unsigned int nvec, unsigned int pos)
 {
-	return -EINVAL;
+	unsigned int i;
+
+	for (i = 0; i < nvec; i++) {
+		irq_set_msi_desc_off(irq_base, i, NULL);
+		/* Disable corresponding interrupt on MSI controller */
+		if (pp->ops->msi_clear_irq)
+			pp->ops->msi_clear_irq(pp, pos + i);
+		else
+			dw_pcie_msi_clear_irq(pp, pos + i);
+	}
+
+	bitmap_release_region(pp->msi_irq_in_use, pos, order_base_2(nvec));
 }
 
-static void dw_pci_bottom_mask(struct irq_data *data)
+static void dw_pcie_msi_set_irq(struct pcie_port *pp, int irq)
 {
-	struct pcie_port *pp = irq_data_get_irq_chip_data(data);
-	unsigned int res, bit, ctrl;
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&pp->lock, flags);
-
-	if (pp->ops->msi_clear_irq) {
-		pp->ops->msi_clear_irq(pp, data->hwirq);
-	} else {
-		ctrl = data->hwirq / 32;
-		res = ctrl * 12;
-		bit = data->hwirq % 32;
-
-		pp->irq_status[ctrl] &= ~(1 << bit);
-		dw_pcie_wr_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4,
-				    pp->irq_status[ctrl]);
-	}
+	unsigned int res, bit, val;
 
-	raw_spin_unlock_irqrestore(&pp->lock, flags);
+	res = (irq / 32) * 12;
+	bit = irq % 32;
+	dw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4, &val);
+	val |= 1 << bit;
+	dw_pcie_wr_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4, val);
 }
 
-static void dw_pci_bottom_unmask(struct irq_data *data)
+static int assign_irq(int no_irqs, struct msi_desc *desc, int *pos)
 {
-	struct pcie_port *pp = irq_data_get_irq_chip_data(data);
-	unsigned int res, bit, ctrl;
-	unsigned long flags;
+	int irq, pos0, i;
+	struct pcie_port *pp;
 
-	raw_spin_lock_irqsave(&pp->lock, flags);
+	pp = (struct pcie_port *)msi_desc_to_pci_sysdata(desc);
+	pos0 = bitmap_find_free_region(pp->msi_irq_in_use, MAX_MSI_IRQS,
+				       order_base_2(no_irqs));
+	if (pos0 < 0)
+		goto no_valid_irq;
 
-	if (pp->ops->msi_set_irq) {
-		pp->ops->msi_set_irq(pp, data->hwirq);
-	} else {
-		ctrl = data->hwirq / 32;
-		res = ctrl * 12;
-		bit = data->hwirq % 32;
+	irq = irq_find_mapping(pp->irq_domain, pos0);
+	if (!irq)
+		goto no_valid_irq;
 
-		pp->irq_status[ctrl] |= 1 << bit;
-		dw_pcie_wr_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4,
-				    pp->irq_status[ctrl]);
+	/*
+	 * irq_create_mapping (called from dw_pcie_host_init) pre-allocates
+	 * descs so there is no need to allocate descs here. We can therefore
+	 * assume that if irq_find_mapping above returns non-zero, then the
+	 * descs are also successfully allocated.
+	 */
+
+	for (i = 0; i < no_irqs; i++) {
+		if (irq_set_msi_desc_off(irq, i, desc) != 0) {
+			clear_irq_range(pp, irq, i, pos0);
+			goto no_valid_irq;
+		}
+		/*Enable corresponding interrupt in MSI interrupt controller */
+		if (pp->ops->msi_set_irq)
+			pp->ops->msi_set_irq(pp, pos0 + i);
+		else
+			dw_pcie_msi_set_irq(pp, pos0 + i);
 	}
 
-	raw_spin_unlock_irqrestore(&pp->lock, flags);
+	*pos = pos0;
+	desc->nvec_used = no_irqs;
+	desc->msi_attrib.multiple = order_base_2(no_irqs);
+
+	return irq;
+
+no_valid_irq:
+	*pos = pos0;
+	return -ENOSPC;
 }
 
-static void dw_pci_bottom_ack(struct irq_data *d)
+static void dw_msi_setup_msg(struct pcie_port *pp, unsigned int irq, u32 pos)
 {
-	struct msi_desc *msi = irq_data_get_msi_desc(d);
-	struct pcie_port *pp;
-
-	pp = msi_desc_to_pci_sysdata(msi);
+	struct msi_msg msg;
+	u64 msi_target;
 
-	if (pp->ops->msi_irq_ack)
-		pp->ops->msi_irq_ack(d->hwirq, pp);
-}
+	if (pp->ops->get_msi_addr)
+		msi_target = pp->ops->get_msi_addr(pp);
+	else
+		msi_target = virt_to_phys((void *)pp->msi_data);
 
-static struct irq_chip dw_pci_msi_bottom_irq_chip = {
-	.name = "DWPCI-MSI",
-	.irq_ack = dw_pci_bottom_ack,
-	.irq_compose_msi_msg = dw_pci_setup_msi_msg,
-	.irq_set_affinity = dw_pci_msi_set_affinity,
-	.irq_mask = dw_pci_bottom_mask,
-	.irq_unmask = dw_pci_bottom_unmask,
-};
+	msg.address_lo = (u32)(msi_target & 0xffffffff);
+	msg.address_hi = (u32)(msi_target >> 32 & 0xffffffff);
 
-static int dw_pcie_irq_domain_alloc(struct irq_domain *domain,
-				    unsigned int virq, unsigned int nr_irqs,
-				    void *args)
-{
-	struct pcie_port *pp = domain->host_data;
-	unsigned long flags;
-	u32 i;
-	int bit;
+	if (pp->ops->get_msi_data)
+		msg.data = pp->ops->get_msi_data(pp, pos);
+	else
+		msg.data = pos;
 
-	raw_spin_lock_irqsave(&pp->lock, flags);
+	pci_write_msi_msg(irq, &msg);
+}
 
-	bit = bitmap_find_free_region(pp->msi_irq_in_use, pp->num_vectors,
-				      order_base_2(nr_irqs));
+static int dw_msi_setup_irq(struct msi_controller *chip, struct pci_dev *pdev,
+			    struct msi_desc *desc)
+{
+	int irq, pos;
+	struct pcie_port *pp = pdev->bus->sysdata;
 
-	raw_spin_unlock_irqrestore(&pp->lock, flags);
+	if (desc->msi_attrib.is_msix)
+		return -EINVAL;
 
-	if (bit < 0)
-		return -ENOSPC;
+	irq = assign_irq(1, desc, &pos);
+	if (irq < 0)
+		return irq;
 
-	for (i = 0; i < nr_irqs; i++)
-		irq_domain_set_info(domain, virq + i, bit + i,
-				    &dw_pci_msi_bottom_irq_chip,
-				    pp, handle_edge_irq,
-				    NULL, NULL);
+	dw_msi_setup_msg(pp, irq, pos);
 
 	return 0;
 }
 
-static void dw_pcie_irq_domain_free(struct irq_domain *domain,
-				    unsigned int virq, unsigned int nr_irqs)
+static int dw_msi_setup_irqs(struct msi_controller *chip, struct pci_dev *pdev,
+			     int nvec, int type)
 {
-	struct irq_data *data = irq_domain_get_irq_data(domain, virq);
-	struct pcie_port *pp = irq_data_get_irq_chip_data(data);
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&pp->lock, flags);
-	bitmap_release_region(pp->msi_irq_in_use, data->hwirq,
-			      order_base_2(nr_irqs));
-	raw_spin_unlock_irqrestore(&pp->lock, flags);
-}
+#ifdef CONFIG_PCI_MSI
+	int irq, pos;
+	struct msi_desc *desc;
+	struct pcie_port *pp = pdev->bus->sysdata;
 
-static const struct irq_domain_ops dw_pcie_msi_domain_ops = {
-	.alloc	= dw_pcie_irq_domain_alloc,
-	.free	= dw_pcie_irq_domain_free,
-};
+	/* MSI-X interrupts are not supported */
+	if (type == PCI_CAP_ID_MSIX)
+		return -EINVAL;
 
-int dw_pcie_allocate_domains(struct pcie_port *pp)
-{
-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
-	struct fwnode_handle *fwnode = of_node_to_fwnode(pci->dev->of_node);
+	WARN_ON(!list_is_singular(&pdev->dev.msi_list));
+	desc = list_entry(pdev->dev.msi_list.next, struct msi_desc, list);
 
-	pp->irq_domain = irq_domain_create_linear(fwnode, pp->num_vectors,
-					       &dw_pcie_msi_domain_ops, pp);
-	if (!pp->irq_domain) {
-		dev_err(pci->dev, "failed to create IRQ domain\n");
-		return -ENOMEM;
-	}
+	irq = assign_irq(nvec, desc, &pos);
+	if (irq < 0)
+		return irq;
 
-	pp->msi_domain = pci_msi_create_irq_domain(fwnode,
-						   &dw_pcie_msi_domain_info,
-						   pp->irq_domain);
-	if (!pp->msi_domain) {
-		dev_err(pci->dev, "failed to create MSI domain\n");
-		irq_domain_remove(pp->irq_domain);
-		return -ENOMEM;
-	}
+	dw_msi_setup_msg(pp, irq, pos);
 
 	return 0;
+#else
+	return -EINVAL;
+#endif
 }
 
-void dw_pcie_free_msi(struct pcie_port *pp)
+static void dw_msi_teardown_irq(struct msi_controller *chip, unsigned int irq)
 {
-	irq_set_chained_handler(pp->msi_irq, NULL);
-	irq_set_handler_data(pp->msi_irq, NULL);
+	struct irq_data *data = irq_get_irq_data(irq);
+	struct msi_desc *msi = irq_data_get_msi_desc(data);
+	struct pcie_port *pp = (struct pcie_port *)msi_desc_to_pci_sysdata(msi);
 
-	irq_domain_remove(pp->msi_domain);
-	irq_domain_remove(pp->irq_domain);
+	clear_irq_range(pp, irq, 1, data->hwirq);
 }
 
-void dw_pcie_msi_init(struct pcie_port *pp)
-{
-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
-	struct device *dev = pci->dev;
-	struct page *page;
-	u64 msi_target;
+static struct msi_controller dw_pcie_msi_chip = {
+	.setup_irq = dw_msi_setup_irq,
+	.setup_irqs = dw_msi_setup_irqs,
+	.teardown_irq = dw_msi_teardown_irq,
+};
 
-	page = alloc_page(GFP_KERNEL);
-	pp->msi_data = dma_map_page(dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);
-	if (dma_mapping_error(dev, pp->msi_data)) {
-		dev_err(dev, "failed to map MSI data\n");
-		__free_page(page);
-		return;
-	}
-	msi_target = (u64)pp->msi_data;
+static int dw_pcie_msi_map(struct irq_domain *domain, unsigned int irq,
+			   irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq, &dw_msi_irq_chip, handle_simple_irq);
+	irq_set_chip_data(irq, domain->host_data);
 
-	/* program the msi_data */
-	dw_pcie_wr_own_conf(pp, PCIE_MSI_ADDR_LO, 4,
-			    lower_32_bits(msi_target));
-	dw_pcie_wr_own_conf(pp, PCIE_MSI_ADDR_HI, 4,
-			    upper_32_bits(msi_target));
+	return 0;
 }
 
+static const struct irq_domain_ops msi_domain_ops = {
+	.map = dw_pcie_msi_map,
+};
+
 int dw_pcie_host_init(struct pcie_port *pp)
 {
 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
 	struct device *dev = pci->dev;
 	struct device_node *np = dev->of_node;
 	struct platform_device *pdev = to_platform_device(dev);
-	struct resource_entry *win, *tmp;
 	struct pci_bus *bus, *child;
 	struct pci_host_bridge *bridge;
 	struct resource *cfg_res;
-	int ret;
-
-	raw_spin_lock_init(&pci->pp.lock);
+	int i, ret;
+	struct resource_entry *win, *tmp;
 
 	cfg_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "config");
 	if (cfg_res) {
@@ -428,35 +382,20 @@ int dw_pcie_host_init(struct pcie_port *pp)
 		pci->num_viewport = 2;
 
 	if (IS_ENABLED(CONFIG_PCI_MSI)) {
-		/*
-		 * If a specific SoC driver needs to change the
-		 * default number of vectors, it needs to implement
-		 * the set_num_vectors callback.
-		 */
-		if (!pp->ops->set_num_vectors) {
-			pp->num_vectors = MSI_DEF_NUM_VECTORS;
-		} else {
-			pp->ops->set_num_vectors(pp);
-
-			if (pp->num_vectors > MAX_MSI_IRQS ||
-			    pp->num_vectors == 0) {
-				dev_err(dev,
-					"Invalid number of vectors\n");
-				goto error;
-			}
-		}
-
 		if (!pp->ops->msi_host_init) {
-			ret = dw_pcie_allocate_domains(pp);
-			if (ret)
+			pp->irq_domain = irq_domain_add_linear(dev->of_node,
+						MAX_MSI_IRQS, &msi_domain_ops,
+						&dw_pcie_msi_chip);
+			if (!pp->irq_domain) {
+				dev_err(dev, "irq domain init failed\n");
+				ret = -ENXIO;
 				goto error;
+			}
 
-			if (pp->msi_irq)
-				irq_set_chained_handler_and_data(pp->msi_irq,
-							    dw_chained_msi_isr,
-							    pp);
+			for (i = 0; i < MAX_MSI_IRQS; i++)
+				irq_create_mapping(pp->irq_domain, i);
 		} else {
-			ret = pp->ops->msi_host_init(pp);
+			ret = pp->ops->msi_host_init(pp, &dw_pcie_msi_chip);
 			if (ret < 0)
 				goto error;
 		}
@@ -476,6 +415,10 @@ int dw_pcie_host_init(struct pcie_port *pp)
 	bridge->ops = &dw_pcie_ops;
 	bridge->map_irq = of_irq_parse_and_map_pci;
 	bridge->swizzle_irq = pci_common_swizzle;
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		bridge->msi = &dw_pcie_msi_chip;
+		dw_pcie_msi_chip.dev = dev;
+	}
 
 	ret = pci_scan_root_bus_bridge(bridge);
 	if (ret)
@@ -631,19 +574,24 @@ static struct pci_ops dw_pcie_ops = {
 	.write = dw_pcie_wr_conf,
 };
 
+static u8 dw_pcie_iatu_unroll_enabled(struct dw_pcie *pci)
+{
+	u32 val;
+
+	val = dw_pcie_readl_dbi(pci, PCIE_ATU_VIEWPORT);
+	if (val == 0xffffffff)
+		return 1;
+
+	return 0;
+}
+
 void dw_pcie_setup_rc(struct pcie_port *pp)
 {
-	u32 val, ctrl, num_ctrls;
+	u32 val;
 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
 
 	dw_pcie_setup(pci);
 
-	num_ctrls = pp->num_vectors / MAX_MSI_IRQS_PER_CTRL;
-
-	/* Initialize IRQ Status array */
-	for (ctrl = 0; ctrl < num_ctrls; ctrl++)
-		dw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_ENABLE + (ctrl * 12), 4,
-				    &pp->irq_status[ctrl]);
 	/* setup RC BARs */
 	dw_pcie_writel_dbi(pci, PCI_BASE_ADDRESS_0, 0x00000004);
 	dw_pcie_writel_dbi(pci, PCI_BASE_ADDRESS_1, 0x00000000);
@@ -675,6 +623,11 @@ void dw_pcie_setup_rc(struct pcie_port *pp)
 	 * we should not program the ATU here.
 	 */
 	if (!pp->ops->rd_other_conf) {
+		/* get iATU unroll support */
+		pci->iatu_unroll_enabled = dw_pcie_iatu_unroll_enabled(pci);
+		dev_dbg(pci->dev, "iATU unroll: %s\n",
+			pci->iatu_unroll_enabled ? "enabled" : "disabled");
+
 		dw_pcie_prog_outbound_atu(pci, PCIE_ATU_REGION_INDEX0,
 					  PCIE_ATU_TYPE_MEM, pp->mem_base,
 					  pp->mem_bus_addr, pp->mem_size);
diff --git a/drivers/thermal/hisi_thermal.c b/drivers/thermal/hisi_thermal.c
index 7c5d4647cb5e..6d8906d65476 100644
--- a/drivers/thermal/hisi_thermal.c
+++ b/drivers/thermal/hisi_thermal.c
@@ -26,12 +26,9 @@
 
 #include "thermal_core.h"
 
-#define TEMP0_LAG			(0x0)
 #define TEMP0_TH			(0x4)
 #define TEMP0_RST_TH			(0x8)
 #define TEMP0_CFG			(0xC)
-#define TEMP0_CFG_SS_MSK		(0xF000)
-#define TEMP0_CFG_HDAK_MSK		(0x30)
 #define TEMP0_EN			(0x10)
 #define TEMP0_INT_EN			(0x14)
 #define TEMP0_INT_CLR			(0x18)
@@ -41,10 +38,8 @@
 #define HISI_TEMP_BASE			(-60000)
 #define HISI_TEMP_RESET			(100000)
 #define HISI_TEMP_STEP			(784)
-#define HISI_TEMP_LAG			(3500)
 
 #define HISI_MAX_SENSORS		4
-#define HISI_DEFAULT_SENSOR		2
 
 struct hisi_thermal_sensor {
 	struct hisi_thermal_data *thermal;
@@ -59,8 +54,11 @@ struct hisi_thermal_data {
 	struct mutex thermal_lock;    /* protects register data */
 	struct platform_device *pdev;
 	struct clk *clk;
-	struct hisi_thermal_sensor sensors;
-	int irq;
+	struct hisi_thermal_sensor sensors[HISI_MAX_SENSORS];
+
+	int irq, irq_bind_sensor;
+	bool irq_enabled;
+
 	void __iomem *regs;
 };
 
@@ -98,107 +96,72 @@ static inline long hisi_thermal_round_temp(int temp)
 		hisi_thermal_temp_to_step(temp));
 }
 
-/*
- * The lag register contains 5 bits encoding the temperature in steps.
- *
- * Each time the temperature crosses the threshold boundary, an
- * interrupt is raised. It could be when the temperature is going
- * above the threshold or below. However, if the temperature is
- * fluctuating around this value due to the load, we can receive
- * several interrupts which may not desired.
- *
- * We can setup a temperature representing the delta between the
- * threshold and the current temperature when the temperature is
- * decreasing.
- *
- * For instance: the lag register is 5°C, the threshold is 65°C, when
- * the temperature reaches 65°C an interrupt is raised and when the
- * temperature decrease to 65°C - 5°C another interrupt is raised.
- *
- * A very short lag can lead to an interrupt storm, a long lag
- * increase the latency to react to the temperature changes.  In our
- * case, that is not really a problem as we are polling the
- * temperature.
- *
- * [0:4] : lag register
- *
- * The temperature is coded in steps, cf. HISI_TEMP_STEP.
- *
- * Min : 0x00 :  0.0 °C
- * Max : 0x1F : 24.3 °C
- *
- * The 'value' parameter is in milliCelsius.
- */
-static inline void hisi_thermal_set_lag(void __iomem *addr, int value)
+static long hisi_thermal_get_sensor_temp(struct hisi_thermal_data *data,
+					 struct hisi_thermal_sensor *sensor)
 {
-	writel((value / HISI_TEMP_STEP) & 0x1F, addr + TEMP0_LAG);
-}
+	long val;
 
-static inline void hisi_thermal_alarm_clear(void __iomem *addr, int value)
-{
-	writel(value, addr + TEMP0_INT_CLR);
-}
+	mutex_lock(&data->thermal_lock);
 
-static inline void hisi_thermal_alarm_enable(void __iomem *addr, int value)
-{
-	writel(value, addr + TEMP0_INT_EN);
-}
+	/* disable interrupt */
+	writel(0x0, data->regs + TEMP0_INT_EN);
+	writel(0x1, data->regs + TEMP0_INT_CLR);
 
-static inline void hisi_thermal_alarm_set(void __iomem *addr, int temp)
-{
-	writel(hisi_thermal_temp_to_step(temp) | 0x0FFFFFF00, addr + TEMP0_TH);
-}
+	/* disable module firstly */
+	writel(0x0, data->regs + TEMP0_EN);
 
-static inline void hisi_thermal_reset_set(void __iomem *addr, int temp)
-{
-	writel(hisi_thermal_temp_to_step(temp), addr + TEMP0_RST_TH);
-}
+	/* select sensor id */
+	writel((sensor->id << 12), data->regs + TEMP0_CFG);
 
-static inline void hisi_thermal_reset_enable(void __iomem *addr, int value)
-{
-	writel(value, addr + TEMP0_RST_MSK);
-}
+	/* enable module */
+	writel(0x1, data->regs + TEMP0_EN);
 
-static inline void hisi_thermal_enable(void __iomem *addr, int value)
-{
-	writel(value, addr + TEMP0_EN);
-}
+	usleep_range(3000, 5000);
 
-static inline int hisi_thermal_get_temperature(void __iomem *addr)
-{
-	return hisi_thermal_step_to_temp(readl(addr + TEMP0_VALUE));
-}
+	val = readl(data->regs + TEMP0_VALUE);
+	val = hisi_thermal_step_to_temp(val);
 
-/*
- * Temperature configuration register - Sensor selection
- *
- * Bits [19:12]
- *
- * 0x0: local sensor (default)
- * 0x1: remote sensor 1 (ACPU cluster 1)
- * 0x2: remote sensor 2 (ACPU cluster 0)
- * 0x3: remote sensor 3 (G3D)
- */
-static inline void hisi_thermal_sensor_select(void __iomem *addr, int sensor)
-{
-	writel((readl(addr + TEMP0_CFG) & ~TEMP0_CFG_SS_MSK) |
-	       (sensor << 12), addr + TEMP0_CFG);
+	mutex_unlock(&data->thermal_lock);
+
+	return val;
 }
 
-/*
- * Temperature configuration register - Hdak conversion polling interval
- *
- * Bits [5:4]
- *
- * 0x0 :   0.768 ms
- * 0x1 :   6.144 ms
- * 0x2 :  49.152 ms
- * 0x3 : 393.216 ms
- */
-static inline void hisi_thermal_hdak_set(void __iomem *addr, int value)
+static void hisi_thermal_enable_bind_irq_sensor
+			(struct hisi_thermal_data *data)
 {
-	writel((readl(addr + TEMP0_CFG) & ~TEMP0_CFG_HDAK_MSK) |
-	       (value << 4), addr + TEMP0_CFG);
+	struct hisi_thermal_sensor *sensor;
+
+	mutex_lock(&data->thermal_lock);
+
+	sensor = &data->sensors[data->irq_bind_sensor];
+
+	/* setting the hdak time */
+	writel(0x0, data->regs + TEMP0_CFG);
+
+	/* disable module firstly */
+	writel(0x0, data->regs + TEMP0_RST_MSK);
+	writel(0x0, data->regs + TEMP0_EN);
+
+	/* select sensor id */
+	writel((sensor->id << 12), data->regs + TEMP0_CFG);
+
+	/* enable for interrupt */
+	writel(hisi_thermal_temp_to_step(sensor->thres_temp) | 0x0FFFFFF00,
+	       data->regs + TEMP0_TH);
+
+	writel(hisi_thermal_temp_to_step(HISI_TEMP_RESET),
+	       data->regs + TEMP0_RST_TH);
+
+	/* enable module */
+	writel(0x1, data->regs + TEMP0_RST_MSK);
+	writel(0x1, data->regs + TEMP0_EN);
+
+	writel(0x0, data->regs + TEMP0_INT_CLR);
+	writel(0x1, data->regs + TEMP0_INT_EN);
+
+	usleep_range(3000, 5000);
+
+	mutex_unlock(&data->thermal_lock);
 }
 
 static void hisi_thermal_disable_sensor(struct hisi_thermal_data *data)
@@ -206,9 +169,9 @@ static void hisi_thermal_disable_sensor(struct hisi_thermal_data *data)
 	mutex_lock(&data->thermal_lock);
 
 	/* disable sensor module */
-	hisi_thermal_enable(data->regs, 0);
-	hisi_thermal_alarm_enable(data->regs, 0);
-	hisi_thermal_reset_enable(data->regs, 0);
+	writel(0x0, data->regs + TEMP0_INT_EN);
+	writel(0x0, data->regs + TEMP0_RST_MSK);
+	writel(0x0, data->regs + TEMP0_EN);
 
 	mutex_unlock(&data->thermal_lock);
 }
@@ -218,10 +181,48 @@ static int hisi_thermal_get_temp(void *_sensor, int *temp)
 	struct hisi_thermal_sensor *sensor = _sensor;
 	struct hisi_thermal_data *data = sensor->thermal;
 
-	*temp = hisi_thermal_get_temperature(data->regs);
+	int sensor_id = -1, i;
+	long max_temp = 0;
 
-	dev_dbg(&data->pdev->dev, "id=%d, temp=%d, thres=%d\n",
-		sensor->id, *temp, sensor->thres_temp);
+	*temp = hisi_thermal_get_sensor_temp(data, sensor);
+
+	sensor->sensor_temp = *temp;
+
+	for (i = 0; i < HISI_MAX_SENSORS; i++) {
+		if (!data->sensors[i].tzd)
+			continue;
+
+		if (data->sensors[i].sensor_temp >= max_temp) {
+			max_temp = data->sensors[i].sensor_temp;
+			sensor_id = i;
+		}
+	}
+
+	/* If no sensor has been enabled, then skip to enable irq */
+	if (sensor_id == -1)
+		return 0;
+
+	mutex_lock(&data->thermal_lock);
+	data->irq_bind_sensor = sensor_id;
+	mutex_unlock(&data->thermal_lock);
+
+	dev_dbg(&data->pdev->dev, "id=%d, irq=%d, temp=%d, thres=%d\n",
+		sensor->id, data->irq_enabled, *temp, sensor->thres_temp);
+	/*
+	 * Bind irq to sensor for two cases:
+	 *   Reenable alarm IRQ if temperature below threshold;
+	 *   if irq has been enabled, always set it;
+	 */
+	if (data->irq_enabled) {
+		hisi_thermal_enable_bind_irq_sensor(data);
+		return 0;
+	}
+
+	if (max_temp < sensor->thres_temp) {
+		data->irq_enabled = true;
+		hisi_thermal_enable_bind_irq_sensor(data);
+		enable_irq(data->irq);
+	}
 
 	return 0;
 }
@@ -230,26 +231,35 @@ static const struct thermal_zone_of_device_ops hisi_of_thermal_ops = {
 	.get_temp = hisi_thermal_get_temp,
 };
 
+static irqreturn_t hisi_thermal_alarm_irq(int irq, void *dev)
+{
+	struct hisi_thermal_data *data = dev;
+
+	disable_irq_nosync(irq);
+	data->irq_enabled = false;
+
+	return IRQ_WAKE_THREAD;
+}
+
 static irqreturn_t hisi_thermal_alarm_irq_thread(int irq, void *dev)
 {
 	struct hisi_thermal_data *data = dev;
-	struct hisi_thermal_sensor *sensor = &data->sensors;
-	int temp;
+	struct hisi_thermal_sensor *sensor;
+	int i;
 
-	hisi_thermal_alarm_clear(data->regs, 1);
+	mutex_lock(&data->thermal_lock);
+	sensor = &data->sensors[data->irq_bind_sensor];
 
-	temp = hisi_thermal_get_temperature(data->regs);
+	dev_crit(&data->pdev->dev, "THERMAL ALARM: T > %d\n",
+		 sensor->thres_temp);
+	mutex_unlock(&data->thermal_lock);
 
-	if (temp >= sensor->thres_temp) {
-		dev_crit(&data->pdev->dev, "THERMAL ALARM: %d > %d\n",
-			 temp, sensor->thres_temp);
+	for (i = 0; i < HISI_MAX_SENSORS; i++) {
+		if (!data->sensors[i].tzd)
+			continue;
 
-		thermal_zone_device_update(data->sensors.tzd,
+		thermal_zone_device_update(data->sensors[i].tzd,
 					   THERMAL_EVENT_UNSPECIFIED);
-
-	} else if (temp < sensor->thres_temp) {
-		dev_crit(&data->pdev->dev, "THERMAL ALARM stopped: %d < %d\n",
-			 temp, sensor->thres_temp);
 	}
 
 	return IRQ_HANDLED;
@@ -303,44 +313,11 @@ static void hisi_thermal_toggle_sensor(struct hisi_thermal_sensor *sensor,
 		on ? THERMAL_DEVICE_ENABLED : THERMAL_DEVICE_DISABLED);
 }
 
-static int hisi_thermal_setup(struct hisi_thermal_data *data)
-{
-	struct hisi_thermal_sensor *sensor;
-
-	sensor = &data->sensors;
-
-	/* disable module firstly */
-	hisi_thermal_reset_enable(data->regs, 0);
-	hisi_thermal_enable(data->regs, 0);
-
-	/* select sensor id */
-	hisi_thermal_sensor_select(data->regs, sensor->id);
-
-	/* setting the hdak time */
-	hisi_thermal_hdak_set(data->regs, 0);
-
-	/* setting lag value between current temp and the threshold */
-	hisi_thermal_set_lag(data->regs, HISI_TEMP_LAG);
-
-	/* enable for interrupt */
-	hisi_thermal_alarm_set(data->regs, sensor->thres_temp);
-
-	hisi_thermal_reset_set(data->regs, HISI_TEMP_RESET);
-
-	/* enable module */
-	hisi_thermal_reset_enable(data->regs, 1);
-	hisi_thermal_enable(data->regs, 1);
-
-	hisi_thermal_alarm_clear(data->regs, 0);
-	hisi_thermal_alarm_enable(data->regs, 1);
-
-	return 0;
-}
-
 static int hisi_thermal_probe(struct platform_device *pdev)
 {
 	struct hisi_thermal_data *data;
 	struct resource *res;
+	int i;
 	int ret;
 
 	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
@@ -379,30 +356,29 @@ static int hisi_thermal_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = hisi_thermal_register_sensor(pdev, data,
-					   &data->sensors,
-					   HISI_DEFAULT_SENSOR);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to register thermal sensor: %d\n",
-			ret);
-		return ret;
-	}
+	hisi_thermal_enable_bind_irq_sensor(data);
+	data->irq_enabled = true;
 
-	ret = hisi_thermal_setup(data);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to setup the sensor: %d\n", ret);
-		return ret;
+	for (i = 0; i < HISI_MAX_SENSORS; ++i) {
+		ret = hisi_thermal_register_sensor(pdev, data,
+						   &data->sensors[i], i);
+		if (ret)
+			dev_err(&pdev->dev,
+				"failed to register thermal sensor: %d\n", ret);
+		else
+			hisi_thermal_toggle_sensor(&data->sensors[i], true);
 	}
 
-	ret = devm_request_threaded_irq(&pdev->dev, data->irq, NULL,
+	ret = devm_request_threaded_irq(&pdev->dev, data->irq,
+					hisi_thermal_alarm_irq,
 					hisi_thermal_alarm_irq_thread,
-					IRQF_ONESHOT, "hisi_thermal", data);
+					0, "hisi_thermal", data);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "failed to request alarm irq: %d\n", ret);
 		return ret;
 	}
 
-	hisi_thermal_toggle_sensor(&data->sensors, true);
+	enable_irq(data->irq);
 
 	return 0;
 }
@@ -410,9 +386,17 @@ static int hisi_thermal_probe(struct platform_device *pdev)
 static int hisi_thermal_remove(struct platform_device *pdev)
 {
 	struct hisi_thermal_data *data = platform_get_drvdata(pdev);
-	struct hisi_thermal_sensor *sensor = &data->sensors;
+	int i;
+
+	for (i = 0; i < HISI_MAX_SENSORS; i++) {
+		struct hisi_thermal_sensor *sensor = &data->sensors[i];
+
+		if (!sensor->tzd)
+			continue;
+
+		hisi_thermal_toggle_sensor(sensor, false);
+	}
 
-	hisi_thermal_toggle_sensor(sensor, false);
 	hisi_thermal_disable_sensor(data);
 	clk_disable_unprepare(data->clk);
 
@@ -425,6 +409,7 @@ static int hisi_thermal_suspend(struct device *dev)
 	struct hisi_thermal_data *data = dev_get_drvdata(dev);
 
 	hisi_thermal_disable_sensor(data);
+	data->irq_enabled = false;
 
 	clk_disable_unprepare(data->clk);
 
@@ -440,7 +425,8 @@ static int hisi_thermal_resume(struct device *dev)
 	if (ret)
 		return ret;
 
-	hisi_thermal_setup(data);
+	data->irq_enabled = true;
+	hisi_thermal_enable_bind_irq_sensor(data);
 
 	return 0;
 }
-- 
2.20.1

