From afed4ee82997cc948b6246465ff3727ac526c9c7 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Mon, 24 Aug 2015 14:23:26 -0500
Subject: [PATCH 8/8] Revert "drm/omap: add manager properties"

This reverts commit fac75addbe9b2d6fb54d07861ab38beb63e0c24b.

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/gpu/drm/omapdrm/omap_crtc.c | 145 +++++++-----------------------------
 drivers/gpu/drm/omapdrm/omap_drv.c  |  31 --------
 drivers/gpu/drm/omapdrm/omap_drv.h  |   8 +-
 3 files changed, 26 insertions(+), 158 deletions(-)

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 0ad9a94..69825ba 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -55,11 +55,6 @@ struct omap_crtc {
 
 struct omap_crtc_state {
 	struct drm_crtc_state base;
-
-	unsigned int trans_key_mode;
-	unsigned int trans_key;
-	unsigned int default_color;
-	bool partial_alpha_enabled;
 };
 
 static inline struct omap_crtc_state *
@@ -209,7 +204,15 @@ static void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)
 static int omap_crtc_dss_enable(struct omap_overlay_manager *mgr)
 {
 	struct omap_crtc *omap_crtc = omap_crtcs[mgr->id];
+	struct omap_overlay_manager_info info;
+
+	memset(&info, 0, sizeof(info));
+	info.default_color = 0x00000000;
+	info.trans_key = 0x00000000;
+	info.trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
+	info.trans_enabled = false;
 
+	dispc_mgr_setup(omap_crtc->channel, &info);
 	dispc_mgr_set_timings(omap_crtc->channel,
 			&omap_crtc->timings);
 	omap_crtc_set_enabled(&omap_crtc->base, true);
@@ -335,38 +338,6 @@ static void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)
 	wake_up(&omap_crtc->pending_wait);
 }
 
-static void omap_crtc_write_crtc_properties(struct drm_crtc *crtc)
-{
-	struct omap_crtc *omap_crtc = to_omap_crtc(crtc);
-	struct omap_overlay_manager_info info;
-	const struct omap_crtc_state *omap_state =
-		to_omap_crtc_state(crtc->state);
-
-	memset(&info, 0, sizeof(info));
-	info.default_color = omap_state->default_color;
-
-	info.trans_key = omap_state->trans_key;
-
-	switch (omap_state->trans_key_mode) {
-	case 0:
-	default:
-		info.trans_enabled = false;
-		break;
-	case 1:
-		info.trans_enabled = true;
-		info.trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
-		break;
-	case 2:
-		info.trans_enabled = true;
-		info.trans_key_type = OMAP_DSS_COLOR_KEY_VID_SRC;
-		break;
-	}
-
-	info.partial_alpha_enabled = omap_state->partial_alpha_enabled;
-
-	dispc_mgr_setup(omap_crtc->channel, &info);
-}
-
 /* -----------------------------------------------------------------------------
  * CRTC Functions
  */
@@ -386,11 +357,6 @@ static void omap_crtc_reset(struct drm_crtc *crtc)
 	if (omap_state == NULL)
 		return;
 
-	omap_state->trans_key_mode = 0;
-	omap_state->trans_key = 0;
-	omap_state->default_color = 0;
-	omap_state->partial_alpha_enabled = false;
-
 	crtc->state = &omap_state->base;
 	crtc->state->crtc = crtc;
 }
@@ -466,8 +432,6 @@ static void omap_crtc_atomic_flush(struct drm_crtc *crtc)
 
 	WARN_ON(omap_crtc->vblank_irq.registered);
 
-	omap_crtc_write_crtc_properties(crtc);
-
 	if (dispc_mgr_is_enabled(omap_crtc->channel)) {
 
 		DBG("%s: GO", omap_crtc->name);
@@ -511,51 +475,24 @@ static void omap_crtc_atomic_destroy_state(struct drm_crtc *crtc,
 	kfree(to_omap_crtc_state(state));
 }
 
-static bool omap_crtc_is_plane_prop(struct omap_drm_private *priv,
-	struct drm_property *property)
-{
-	return	property == priv->zorder_prop ||
-		property == priv->global_alpha_prop ||
-		property == priv->pre_mult_alpha_prop;
-}
-
 static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 					 struct drm_crtc_state *state,
 					 struct drm_property *property,
 					 uint64_t val)
 {
-	struct omap_drm_private *priv = crtc->dev->dev_private;
-	struct omap_crtc_state *omap_state = to_omap_crtc_state(state);
+	struct drm_plane_state *plane_state;
+	struct drm_plane *plane = crtc->primary;
 
-	if (omap_crtc_is_plane_prop(priv, property)) {
-		struct drm_plane_state *plane_state;
-		struct drm_plane *plane = crtc->primary;
-
-		/*
-		 * Delegate property set to the primary plane. Get the plane
-		 * state and set the property directly.
-		 */
-
-		plane_state = drm_atomic_get_plane_state(state->state, plane);
-		if (!plane_state)
-			return -EINVAL;
-
-		return drm_atomic_plane_set_property(plane, plane_state,
-			property, val);
-	}
+	/*
+	 * Delegate property set to the primary plane. Get the plane state and
+	 * set the property directly.
+	 */
 
-	if (property == priv->trans_key_mode_prop)
-		omap_state->trans_key_mode = val;
-	else if (property == priv->trans_key_prop)
-		omap_state->trans_key = val;
-	else if (property == priv->background_color_prop)
-		omap_state->default_color = val;
-	else if (property == priv->alpha_blender_prop)
-		omap_state->partial_alpha_enabled = !!val;
-	else
+	plane_state = drm_atomic_get_plane_state(state->state, plane);
+	if (!plane_state)
 		return -EINVAL;
 
-	return 0;
+	return drm_atomic_plane_set_property(plane, plane_state, property, val);
 }
 
 static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
@@ -563,33 +500,14 @@ static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
 					 struct drm_property *property,
 					 uint64_t *val)
 {
-	struct omap_drm_private *priv = crtc->dev->dev_private;
-	const struct omap_crtc_state *omap_state =
-		container_of(state, const struct omap_crtc_state, base);
-
-	if (omap_crtc_is_plane_prop(priv, property)) {
-		/*
-		 * Delegate property get to the primary plane. The
-		 * drm_atomic_plane_get_property() function isn't exported, but
-		 * can be called through drm_object_property_get_value() as that
-		 * will call drm_atomic_get_property() for atomic drivers.
-		 */
-		return drm_object_property_get_value(&crtc->primary->base,
-			property, val);
-	}
-
-	if (property == priv->trans_key_mode_prop)
-		*val = omap_state->trans_key_mode;
-	else if (property == priv->trans_key_prop)
-		*val = omap_state->trans_key;
-	else if (property == priv->background_color_prop)
-		*val = omap_state->default_color;
-	else if (property == priv->alpha_blender_prop)
-		*val = omap_state->partial_alpha_enabled;
-	else
-		return -EINVAL;
-
-	return 0;
+	/*
+	 * Delegate property get to the primary plane. The
+	 * drm_atomic_plane_get_property() function isn't exported, but can be
+	 * called through drm_object_property_get_value() as that will call
+	 * drm_atomic_get_property() for atomic drivers.
+	 */
+	return drm_object_property_get_value(&crtc->primary->base, property,
+					     val);
 }
 
 static const struct drm_crtc_funcs omap_crtc_funcs = {
@@ -634,18 +552,6 @@ void omap_crtc_pre_uninit(void)
 	dss_uninstall_mgr_ops();
 }
 
-static void omap_crtc_install_properties(struct drm_crtc *crtc)
-{
-	struct drm_device *dev = crtc->dev;
-	struct drm_mode_object *obj = &crtc->base;
-	struct omap_drm_private *priv = dev->dev_private;
-
-	drm_object_attach_property(obj, priv->trans_key_mode_prop, 0);
-	drm_object_attach_property(obj, priv->trans_key_prop, 0);
-	drm_object_attach_property(obj, priv->background_color_prop, 0);
-	drm_object_attach_property(obj, priv->alpha_blender_prop, 0);
-}
-
 /* initialize crtc */
 struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 		struct drm_plane *plane, enum omap_channel channel, int id)
@@ -687,7 +593,6 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
 
 	drm_crtc_helper_add(crtc, &omap_crtc_helper_funcs);
 
-	omap_crtc_install_properties(crtc);
 	omap_plane_install_properties(crtc->primary, &crtc->base);
 
 	omap_crtcs[channel] = omap_crtc;
diff --git a/drivers/gpu/drm/omapdrm/omap_drv.c b/drivers/gpu/drm/omapdrm/omap_drv.c
index ea537a5..b52ad52 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.c
+++ b/drivers/gpu/drm/omapdrm/omap_drv.c
@@ -330,14 +330,6 @@ static int omap_modeset_init_properties(struct drm_device *dev)
 {
 	struct omap_drm_private *priv = dev->dev_private;
 
-	static const struct drm_prop_enum_list trans_key_mode_list[] = {
-		{ 0, "disable"},
-		{ 1, "gfx-dst"},
-		{ 2, "vid-src"},
-	};
-
-	/* plane properties */
-
 	if (priv->has_dmm) {
 		dev->mode_config.rotation_property =
 			drm_mode_create_rotation_property(dev,
@@ -362,29 +354,6 @@ static int omap_modeset_init_properties(struct drm_device *dev)
 	if (!priv->pre_mult_alpha_prop)
 		return -ENOMEM;
 
-	/* crtc properties */
-
-	priv->trans_key_mode_prop = drm_property_create_enum(dev, 0,
-		"trans-key-mode",
-		trans_key_mode_list, ARRAY_SIZE(trans_key_mode_list));
-	if (!priv->trans_key_mode_prop)
-		return -ENOMEM;
-
-	priv->trans_key_prop = drm_property_create_range(dev, 0, "trans-key",
-		0, 0xffffff);
-	if (!priv->trans_key_prop)
-		return -ENOMEM;
-
-	priv->background_color_prop = drm_property_create_range(dev, 0,
-		"background", 0, 0xffffff);
-	if (!priv->background_color_prop)
-		return -ENOMEM;
-
-	priv->alpha_blender_prop = drm_property_create_bool(dev, 0,
-		"alpha_blender");
-	if (!priv->alpha_blender_prop)
-		return -ENOMEM;
-
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/omapdrm/omap_drv.h b/drivers/gpu/drm/omapdrm/omap_drv.h
index 84dbaea..48fa99c 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.h
+++ b/drivers/gpu/drm/omapdrm/omap_drv.h
@@ -99,17 +99,11 @@ struct omap_drm_private {
 
 	bool has_dmm;
 
-	/* plane properties */
+	/* properties: */
 	struct drm_property *zorder_prop;
 	struct drm_property *global_alpha_prop;
 	struct drm_property *pre_mult_alpha_prop;
 
-	/* crtc properties */
-	struct drm_property *trans_key_mode_prop;
-	struct drm_property *trans_key_prop;
-	struct drm_property *background_color_prop;
-	struct drm_property *alpha_blender_prop;
-
 	/* irq handling: */
 	struct list_head irq_list;    /* list of omap_drm_irq */
 	uint32_t vblank_mask;         /* irq bits set for userspace vblank */
-- 
2.5.0

